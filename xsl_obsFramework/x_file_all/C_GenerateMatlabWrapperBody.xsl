<?xml version="1.0" encoding="UTF-8"?>

<!--================================================================-->
<!-- Copyright 2003 P&P Software GmbH                               -->
<!--================================================================-->

<!--===================================================================
Generator meta-component for the Matlab wrapper for the OBS Framework.
A "Matlab wrapper" wraps code that generated by the autocode facility of
Matlab and makes it possible to integrate that code within an application
instantiated from the OBS Framework. The Matlab wrapper is given the
form of a component that extends the OBS Framework class
"ControlBlockFloatDbPar".

This XSLT program generates the body of the Matlab wrapper class.

This XSLT program process an XML file that describes the target Matlab
routine. 
===================================================================-->

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    version="1.1"
    xmlns:lxslt="http://xml.apache.org/xslt"
    xmlns:redirect="org.apache.xalan.lib.Redirect"
    extension-element-prefixes="redirect">

<xsl:strip-space elements="*"/>
<xsl:output omit-xml-declaration="yes" method="text"/>

<!--===================================================================
       Include general utility rules
===================================================================-->
 <xsl:include href="ClassNameFromPath.xsl"/>
 <xsl:include href="ClassIdFromClassName.xsl"/>
<!--===================================================================
      Top-level rule 
===================================================================-->
<xsl:template match="/ObsApplication/ControllerManagement/ControlAction/ControlBlock">
<!--===================================================================
      Define general-purpose variables
 ===================================================================-->  
  <xsl:variable name="ClassName">
        <xsl:call-template name="ClassNameFromPath">
              <xsl:with-param name="path" select="MatlabWrapper/@type"/>
        </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="ClassId">
        <xsl:call-template name="ClassIdFromClassName">
              <xsl:with-param name="className" select="$ClassName"/>
        </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="Desc" select="MatlabWrapper/Description"/>
  <xsl:variable name="NumberOfInputs" select="count(Input)"/>
  <xsl:variable name="NumberOfOutputs" select="count(Output)"/>
  <xsl:variable name="NumberOfParameters" select="count(Parameter)"/>
  <xsl:variable name="StepFunct" select="MatlabWrapper/StepFunction/@value"/>
  <xsl:variable name="InitFunct" select="MatlabWrapper/InitFunction/@value"/>
  <xsl:variable name="MatlabHeader" select="MatlabWrapper/MatlabCodeHeaderFile/@value"/>
  <xsl:variable name="CodeDir" select="'../'"/>
  <xsl:variable name="TargetFile" select="concat('/home/wangshaobo/obs_xml_xsl/projects_c/',MatlabWrapper/@type)"/>
  <xsl:variable name="LowerCase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="UpperCase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
            
  Generating code for class <xsl:value-of select="$ClassName"/> in files <xsl:value-of select="$TargetFile"/>.c

  <!-- Check whether writing to an output file is possible -->
  <xsl:if test="not(element-available('xsl:document'))">
        FATAL ERROR: the xsl:document element is not supported. Header files cannot be written! This element
        is normally supported only in version 1.1 of XSL.
  </xsl:if>
            
  <!-- ===================================================================================
         Create the output file  
          ===================================================================================-->
  <xsl:document href="{$TargetFile}.c" omit-xml-declaration="yes" method="text">  
<!--===================================================================
      Start Code Generation
      ===================================================================-->  
//
// Copyright 2003 P&amp;P Software GmbH - All Rights Reserved
//
// <xsl:value-of select="$ClassName"/>.c
//
// This is an automatically generated file

#include "<xsl:value-of select="$CodeDir"/>GeneralInclude/CompilerSwitches.h"
#include "<xsl:value-of select="$CodeDir"/>GeneralInclude/DebugSupport.h"
#include "<xsl:value-of select="$CodeDir"/>GeneralInclude/BasicTypes.h"
#include "<xsl:value-of select="$CodeDir"/>GeneralInclude/ClassId.h"
#include "<xsl:value-of select="$CodeDir"/>GeneralInclude/Constants.h"
#include "<xsl:value-of select="$CodeDir"/>Data/DC_DataItem.h"
#include "<xsl:value-of select="$CodeDir"/>Data/DataPool.h"
#include "<xsl:value-of select="$ClassName"/>.h"

///////////////////////////////////////////////////////////////////////////////
//
//                            class data
//
///////////////////////////////////////////////////////////////////////////////

static unsigned int numberOfInstances=0;
<!--
<xsl:value-of select="$ClassName"/>::<xsl:value-of select="$ClassName"/>() {
    // The Simulink model is NOT reentrant, thus we
    // can only have one instance of this object
    assert(numberOfInstances==0);
    numberOfInstances++;

    numberOfInputs=<xsl:value-of select="$NumberOfInputs"/>;
    numberOfOutputs=<xsl:value-of select="$NumberOfOutputs"/>;
    numberOfParameters=<xsl:value-of select="$NumberOfParameters"/>;

#ifdef HAVE_SIMULINK
    modelStep         =<xsl:value-of select="$StepFunct"/>;
    modelInitialize   =<xsl:value-of select="$InitFunct"/>;

    modelInputs       =new real_T*[numberOfInputs];
    modelOutputs      =new real_T*[numberOfOutputs];
    modelParameters   =new real_T*[numberOfParameters];

    modelInputs[0]    =&amp;Input;
    modelOutputs[0]   =&amp;Output;<xsl:for-each select="Parameter">
    modelParameters[<xsl:value-of select="position()"/>-1]=&amp;<xsl:value-of select="Name/@value"/>;</xsl:for-each>
#endif

    setNumberOfStates(0);
    setNumberOfInputs(numberOfInputs);
    setNumberOfOutputs(numberOfOutputs);
    setNumberOfParameters(numberOfParameters);

    setClassId(<xsl:value-of select="$ClassId"/>);

    // Initialize the Simulink model
    reset();
}

void <xsl:value-of select="$ClassName"/>::propagateState() {
#ifdef HAVE_SIMULINK
    for (unsigned int i=0; i&lt;numberOfParameters; i++)
        *modelParameters[i]=(real_T)p[i];
<xsl:if test="DataPoolLink">
    DataPool* pDP = CC_RootObject::getDataPool();
</xsl:if>
    for (unsigned int i=0; i&lt;numberOfInputs; i++)
        *modelInputs[i]=(real_T)<xsl:text/>
<xsl:choose>
  <xsl:when test="CopyLink">u[i]</xsl:when>
  <xsl:when test="PointerLink">*pU[i]</xsl:when>
  <xsl:when test="DataItemLink">pDIU[i]->getFloatValue()</xsl:when>
  <xsl:when test="DataPoolLink">pDP->getFloatValue(dpu[i])</xsl:when>
</xsl:choose>;
#endif
}

void <xsl:value-of select="$ClassName"/>::updateOutput() {
#ifdef HAVE_SIMULINK
    modelStep();
<xsl:if test="DataPoolLink">
    DataPool* pDP = CC_RootObject::getDataPool();
</xsl:if>
    for (unsigned int i=0;i&lt;numberOfOutputs;i++)
        <xsl:text/>
<xsl:choose>
  <xsl:when test="CopyLink">y[i]=(TD_Float)*modelOutputs[i];</xsl:when>
  <xsl:when test="PointerLink">*pY[i]=(TD_Float)*modelOutputs[i];</xsl:when>
  <xsl:when test="DataItemLink">pDIY[i]->setFloatValue((TD_Float)*modelOutputs[i]);</xsl:when>
  <xsl:when test="DataPoolLink">pDP->setFloatValue(dpy[i],(TD_Float)*modelOutputs[i])</xsl:when>
</xsl:choose>
#endif
}

void <xsl:value-of select="$ClassName"/>::reset() {
#ifdef HAVE_SIMULINK
        modelInitialize(1);
#endif
}
-->


///////////////////////////////////////////////////////////////////////////////
//
//                    non-pure virtual  method(s) definition
//
///////////////////////////////////////////////////////////////////////////////



static void propagateState(void *obj) {
#ifdef HAVE_SIMULINK
    for (unsigned int i=0; i&lt;<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfParameters; i++)
    *<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelParameters[i]=(real_T)<xsl:value-of select="translate('ControlBlock',$LowerCase,$UpperCase)"/>(obj)->p[i];
<xsl:if test="DataPoolLink">
    DataPool* pDP = CC_RootObject_getDataPool();
</xsl:if>
    for (unsigned int i=0; i&lt;<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfInputs; i++)
        *<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelInputs[i]=(real_T)<xsl:text/>
<xsl:choose>
    <xsl:when test="CopyLink"><xsl:value-of select="translate('CopyControlBlock',$LowerCase,$UpperCase)"/>(obj)->u[i]</xsl:when>
  <xsl:when test="PointerLink">*<xsl:value-of select="translate('PointerControlBlock',$LowerCase,$UpperCase)"/>(obj)->pU[i]</xsl:when>
  <xsl:when test="DataItemLink"><xsl:value-of select="translate('DC_DataItem',$LowerCase,$UpperCase)"/>_GET_CLASS(<xsl:value-of select="translate('DataItemControlBlock',$LowerCase,$UpperCase)"/>(obj)->pDIU[i])->getFloatValue()</xsl:when>
  <xsl:when test="DataPoolLink"><xsl:value-of select="translate('DataPool',$LowerCase,$UpperCase)"/>_GET_CLASS(pDP)->getFloatValue(<xsl:value-of select="translate('DataPoolControlBlock',$LowerCase,$UpperCase)"/>(obj)->dpu[i])</xsl:when>
</xsl:choose>;
#endif
}

static void updateOutput(void *obj) {
#ifdef HAVE_SIMULINK
    modelStep();
<xsl:if test="DataPoolLink">
    DataPool* pDP = CC_RootObject_getDataPool();
</xsl:if>
    for (unsigned int i=0;i&lt;<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfOutputs;i++)
        <xsl:text/>
<xsl:choose>
  <xsl:when test="CopyLink"><xsl:value-of select="translate('CopyControlBlock',$LowerCase,$UpperCase)"/>(obj)->y[i]=(TD_Float)*<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelOutputs[i];</xsl:when>
  <xsl:when test="PointerLink">*<xsl:value-of select="translate('PointerControlBlock',$LowerCase,$UpperCase)"/>(obj)->pY[i]=(TD_Float)*<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelOutputs[i];</xsl:when>
  <xsl:when test="DataItemLink"><xsl:value-of select="translate('DC_DataItem',$LowerCase,$UpperCase)"/>_GET_CLASS(<xsl:value-of select="translate('DataItemControlBlock',$LowerCase,$UpperCase)"/>(obj)->pDIY[i])->setFloatValue((TD_Float)*modelOutputs[i]);</xsl:when>
  <xsl:when test="DataPoolLink"><xsl:value-of select="translate('DataPool',$LowerCase,$UpperCase)"/>_GET_CLASS(pDP)->setFloatValue(<xsl:value-of select="translate('DataPoolControlBlock',$LowerCase,$UpperCase)"/>(obj)->dpy[i],(TD_Float)*<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelOutputs[i])</xsl:when>
</xsl:choose>
#endif
}

static void reset(void *obj) {
#ifdef HAVE_SIMULINK
        <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>_GET_CLASS(obj)->modelInitialize(1);
#endif
}


///////////////////////////////////////////////////////////////////////////////
//
//                   object constructor and destructor
//
///////////////////////////////////////////////////////////////////////////////
// the following may be useful if you don't need it, just delete.
// <xsl:value-of select="ClassName"/> *this = <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)
    /**
     * Configure the PID control block. The control block is configured to have one
     * input, one outputs, three parameters. The three parameters represent
     * the proportional, integral and derivative gain. The number of states is
     * set to zero because the state is maintained internally to the
     * Simulink-generated code. The Simulink model is initialized by calling
     * the <code>reset</code> method.
     * The class identifier is set.
     * A pseudo-code implementation of this method therefore is:<pre>
     *    . . . // set up internal data structures to link to matlab code
     *    . . . // set class identifier
     *    setNumberOfStates(0);
     *    setNumberOfInputs(1);
     *    setNumberOfOutputs(1);
     *    setNumberOfParameters(3);
     *    reset(); </pre>
     * Note that the number of states is set to zero because the matlab
     * code already provides a data structure to save the propagation state.
     * <p>
     * This class should only be instantiated once.
     */</p>
static void instance_init(object* obj) {
    // The Simulink model is NOT reentrant, thus we
    // can only have one instance of this object
    assert(numberOfInstances==0);
    numberOfInstances++;

    <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfInputs=<xsl:value-of select="$NumberOfInputs"/>;
    <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfOutputs=<xsl:value-of select="$NumberOfOutputs"/>;
    <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfParameters=<xsl:value-of select="$NumberOfParameters"/>;
#ifdef HAVE_SIMULINK
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelStep =<xsl:value-of select="$StepFunct"/>;
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelInitialize =<xsl:value-of select="$InitFunct"/>;

   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelInputs =(new real_T*)malloc(<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfInputs);
    <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelOutputs =(new real_T*)malloc(<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfOutputs);
    <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelParameters =(real_T*)malloc(<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfParameters);

    <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelInputs[0] =&amp;Input;//这里的Input好像是pid.h里面的
    <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelOutputs[0]   =&amp;Output;<xsl:for-each select="Parameter">
    <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->modelParameters[<xsl:value-of select="position()"/>-1]=&amp;<xsl:value-of select="Name/@value"/>;</xsl:for-each>
#endif
    <xsl:value-of select="translate('ControlBlock',$LowerCase,$UpperCase)"/>_GET_CLASS(obj)->setNumberOfStates(0);
    <xsl:value-of select="translate('ControlBlock',$LowerCase,$UpperCase)"/>_GET_CLASS(obj)->setNumberOfInputs(<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfInputs);
    <xsl:value-of select="translate('ControlBlock',$LowerCase,$UpperCase)"/>_GET_CLASS(obj)->setNumberOfOutputs(<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfOutputs);
    <xsl:value-of select="translate('ControlBlock',$LowerCase,$UpperCase)"/>_GET_CLASS(obj)->setNumberOfParameters(<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->numberOfParameters);

    <xsl:value-of select="translate('CC_RootObject',$LowerCase,$UpperCase)"/>_GET_CLASS(obj)->setClassId(<xsl:value-of select="$ClassId"/>);

    // Initialize the Simulink model
    reset();
}
<xsl:value-of select="$ClassName"/>* <xsl:value-of select="$ClassName"/>_new(void)
{
    return (<xsl:value-of select="$ClassName"/>*)object_new(TYPE_<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>);
}


///////////////////////////////////////////////////////////////////////////////
//
//                   binding and type registration
//
///////////////////////////////////////////////////////////////////////////////

static void class_init(ObjectClass *oc, void *data)
{
    <xsl:value-of select="$ClassName"/>Class *dc_p_class = <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>_CLASS(oc);

    dc_p_class->propagateState=propagateState;
    dc_p_class->updateOutput=updateOutput;
    dc_p_class->reset=reset;
}

static const TypeInfo type_info = {
    .name = TYPE_<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>,
    .parent =
<xsl:choose>
    <xsl:when test="CopyLink"> CopyControlBlockClass</xsl:when>
  <xsl:when test="PointerLink"> PointerControlBlockClass</xsl:when>
  <xsl:when test="DataItemLink"> DataItemControlBlockClass</xsl:when>
  <xsl:when test="DataPoolLink"> DataPoolControlBlockClass</xsl:when>
</xsl:choose>,
    .instance_size = sizeof(<xsl:value-of select="$ClassName"/>),
    .abstract = false,
    .class_size = sizeof(<xsl:value-of select="$ClassName"/>Class),
    .instance_init = instance_init,
    .class_init = class_init,
};

void <xsl:value-of select="$ClassName"/>_register(void)
{
    type_register_static(&amp;type_info);
}
</xsl:document>
</xsl:template>

</xsl:stylesheet>
