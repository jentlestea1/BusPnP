
//
// Copyright 2003 P&P Software GmbH - All Rights Reserved
//
// CC_ManoeuvreFactory.c
//
// This file was automatically generated by an XSL program
//

#include "../GeneralInclude/CompilerSwitches.h"
#include "../GeneralInclude/DebugSupport.h"
#include "../GeneralInclude/BasicTypes.h"
#include "../GeneralInclude/ClassId.h"
#include "../GeneralInclude/Constants.h"  
#include "../Manoeuvre/DC_DummyConfigurableManoeuvre.h"  
#include "../Manoeuvre/DC_DummyManoeuvre.h"  
#include "../Manoeuvre/DC_TestPUSConfigurableManoeuvre.h"  
#include "../Base/CC_RootObject.h"
#include "CC_ManoeuvreFactory.h"


///////////////////////////////////////////////////////////////////////////////
//
//                            class data
//
///////////////////////////////////////////////////////////////////////////////


static CC_ManoeuvreFactory* pInstance=pNULL;     


///////////////////////////////////////////////////////////////////////////////
//
//                            class  method(s) definition
//
///////////////////////////////////////////////////////////////////////////////


CC_ManoeuvreFactory* CC_ManoeuvreFactory_getInstance(void) {
    if (pInstance==pNULL)
        pInstance = CC_ManoeuvreFactory_new();
    return pInstance;
}

///////////////////////////////////////////////////////////////////////////////
//
//                  non-virtual member method(s) definition
//
///////////////////////////////////////////////////////////////////////////////


  
void CC_ManoeuvreFactory_setManoeuvre(CC_ManoeuvreFactory *this,unsigned int i, DC_DummyConfigurableManoeuvre* pItem) {
    assert(i<this->sizeDummyConfigurableManoeuvre);
    assert(pItem!=pNULL);
    
    this->poolDummyConfigurableManoeuvre[i] = pItem;
    DC_DUMMYCONFIGURABLEMANOEUVRE_GET_CLASS(this->poolDummyConfigurableManoeuvre[i])->setInUse(false);
}

unsigned int CC_ManoeuvreFactory_getNumberDummyConfigurableManoeuvre(CC_ManoeuvreFactory *this) {
    unsigned int counter = 0;
    for (unsigned int i=0; i<sizeDummyConfigurableManoeuvre; i++)
        if ( DC_DUMMYCONFIGURABLEMANOEUVRE_GET_CLASS(this->poolDummyConfigurableManoeuvre[i])->isInUse() )
            counter++;
    return counter;
}

unsigned int CC_ManoeuvreFactory_getCapacityDummyConfigurableManoeuvre(CC_ManoeuvreFactory *this) {
    return this->sizeDummyConfigurableManoeuvre;
}
DC_DummyConfigurableManoeuvre* CC_ManoeuvreFactory_allocateDummyConfigurableManoeuvre(CC_ManoeuvreFactory *this, ) {
    assert( this->isObjectConfigured() );
    for (unsigned int i=0; i<this->sizeDummyConfigurableManoeuvre; i++)
    if (!DC_DUMMYCONFIGURABLEMANOEUVRE_GET_CLASS(this->poolDummyConfigurableManoeuvre[i])->isInUse() ) { //这里C_GenerateDynamicFactoryBody.xsl是不是存在问题
        DC_DUMMYCONFIGURABLEMANOEUVRE_GET_CLASS(this->poolDummyConfigurableManoeuvre[i])->setInUse(true);
           return this->poolDummyConfigurableManoeuvre[i];
        }
    return pNULL;
}

bool CC_ManoeuvreFactory_isFreeDummyConfigurableManoeuvre( *this, ) {
    for (unsigned int i=0; i<sizeDummyConfigurableManoeuvre; i++)
        if ( !DC_DUMMYCONFIGURABLEMANOEUVRE_GET_CLASS(this->poolDummyConfigurableManoeuvre[i])->isInUse() )
           return true;

    return false;
}

            
void CC_ManoeuvreFactory_setManoeuvre(CC_ManoeuvreFactory *this,unsigned int i, DC_DummyManoeuvre* pItem) {
    assert(i<this->sizeDummyManoeuvre);
    assert(pItem!=pNULL);
    
    this->poolDummyManoeuvre[i] = pItem;
    DC_DUMMYMANOEUVRE_GET_CLASS(this->poolDummyManoeuvre[i])->setInUse(false);
}

unsigned int CC_ManoeuvreFactory_getNumberDummyManoeuvre(CC_ManoeuvreFactory *this) {
    unsigned int counter = 0;
    for (unsigned int i=0; i<sizeDummyManoeuvre; i++)
        if ( DC_DUMMYMANOEUVRE_GET_CLASS(this->poolDummyManoeuvre[i])->isInUse() )
            counter++;
    return counter;
}

unsigned int CC_ManoeuvreFactory_getCapacityDummyManoeuvre(CC_ManoeuvreFactory *this) {
    return this->sizeDummyManoeuvre;
}
DC_DummyManoeuvre* CC_ManoeuvreFactory_allocateDummyManoeuvre(CC_ManoeuvreFactory *this, ) {
    assert( this->isObjectConfigured() );
    for (unsigned int i=0; i<this->sizeDummyManoeuvre; i++)
    if (!DC_DUMMYMANOEUVRE_GET_CLASS(this->poolDummyManoeuvre[i])->isInUse() ) { //这里C_GenerateDynamicFactoryBody.xsl是不是存在问题
        DC_DUMMYMANOEUVRE_GET_CLASS(this->poolDummyManoeuvre[i])->setInUse(true);
           return this->poolDummyManoeuvre[i];
        }
    return pNULL;
}

bool CC_ManoeuvreFactory_isFreeDummyManoeuvre( *this, ) {
    for (unsigned int i=0; i<sizeDummyManoeuvre; i++)
        if ( !DC_DUMMYMANOEUVRE_GET_CLASS(this->poolDummyManoeuvre[i])->isInUse() )
           return true;

    return false;
}

            
void CC_ManoeuvreFactory_setManoeuvre(CC_ManoeuvreFactory *this,unsigned int i, DC_TestPUSConfigurableManoeuvre* pItem) {
    assert(i<this->sizeTestPUSConfigurableManoeuvre);
    assert(pItem!=pNULL);
    
    this->poolTestPUSConfigurableManoeuvre[i] = pItem;
    DC_TESTPUSCONFIGURABLEMANOEUVRE_GET_CLASS(this->poolTestPUSConfigurableManoeuvre[i])->setInUse(false);
}

unsigned int CC_ManoeuvreFactory_getNumberTestPUSConfigurableManoeuvre(CC_ManoeuvreFactory *this) {
    unsigned int counter = 0;
    for (unsigned int i=0; i<sizeTestPUSConfigurableManoeuvre; i++)
        if ( DC_TESTPUSCONFIGURABLEMANOEUVRE_GET_CLASS(this->poolTestPUSConfigurableManoeuvre[i])->isInUse() )
            counter++;
    return counter;
}

unsigned int CC_ManoeuvreFactory_getCapacityTestPUSConfigurableManoeuvre(CC_ManoeuvreFactory *this) {
    return this->sizeTestPUSConfigurableManoeuvre;
}
DC_TestPUSConfigurableManoeuvre* CC_ManoeuvreFactory_allocateTestPUSConfigurableManoeuvre(CC_ManoeuvreFactory *this, ) {
    assert( this->isObjectConfigured() );
    for (unsigned int i=0; i<this->sizeTestPUSConfigurableManoeuvre; i++)
    if (!DC_TESTPUSCONFIGURABLEMANOEUVRE_GET_CLASS(this->poolTestPUSConfigurableManoeuvre[i])->isInUse() ) { //这里C_GenerateDynamicFactoryBody.xsl是不是存在问题
        DC_TESTPUSCONFIGURABLEMANOEUVRE_GET_CLASS(this->poolTestPUSConfigurableManoeuvre[i])->setInUse(true);
           return this->poolTestPUSConfigurableManoeuvre[i];
        }
    return pNULL;
}

bool CC_ManoeuvreFactory_isFreeTestPUSConfigurableManoeuvre( *this, ) {
    for (unsigned int i=0; i<sizeTestPUSConfigurableManoeuvre; i++)
        if ( !DC_TESTPUSCONFIGURABLEMANOEUVRE_GET_CLASS(this->poolTestPUSConfigurableManoeuvre[i])->isInUse() )
           return true;

    return false;
}

            
/////////////////////////////////////////////////////////////////////////////////
//
//                    non-pure virtual  method(s) definition
//
/////////////////////////////////////////////////////////////////////////////////

static bool isObjectConfigured(void* obj) {

  if ( !CC_ROOTOBJECT(obj)->isObjectConfigured() )
        return false;
  
    if ( CC_MANOEUVREFACTORY(obj)->poolDummyConfigurableManoeuvre==pNULL )
        return false;

    for (unsigned int i=0; i< CC_MANOEUVREFACTORY(obj)->sizeDummyConfigurableManoeuvre; i++)
        if (  CC_MANOEUVREFACTORY(obj)->poolDummyConfigurableManoeuvre[i]==pNULL )
            return false;
     
    if ( CC_MANOEUVREFACTORY(obj)->poolDummyManoeuvre==pNULL )
        return false;

    for (unsigned int i=0; i< CC_MANOEUVREFACTORY(obj)->sizeDummyManoeuvre; i++)
        if (  CC_MANOEUVREFACTORY(obj)->poolDummyManoeuvre[i]==pNULL )
            return false;
     
    if ( CC_MANOEUVREFACTORY(obj)->poolTestPUSConfigurableManoeuvre==pNULL )
        return false;

    for (unsigned int i=0; i< CC_MANOEUVREFACTORY(obj)->sizeTestPUSConfigurableManoeuvre; i++)
        if (  CC_MANOEUVREFACTORY(obj)->poolTestPUSConfigurableManoeuvre[i]==pNULL )
            return false;
     

   return true;
}
///////////////////////////////////////////////////////////////////////////////
//
//                   object constructor and destructor
//
///////////////////////////////////////////////////////////////////////////////
// the following may be useful if you don't need it, just delete.
// CC_ManoeuvreFactory *this = CC_MANOEUVREFACTORY(obj)
static void instance_init(Object *obj)
{
   CC_RootObject_setClassId(ID_MANOEUVREFACTORY);

  CC_MANOEUVREFACTORY(obj)->sizeDummyConfigurableManoeuvre = 1;
     CC_MANOEUVREFACTORY(obj)->poolDummyConfigurableManoeuvre = (DC_DummyConfigurableManoeuvre**)malloc( CC_MANOEUVREFACTORY(obj)->sizeDummyConfigurableManoeuvre*sizeof(DC_DummyConfigurableManoeuvre*));
    for (unsigned int i=0; i< CC_MANOEUVREFACTORY(obj)->sizeDummyConfigurableManoeuvre; i++)
        CC_MANOEUVREFACTORY(obj)->poolDummyConfigurableManoeuvre[i] = pNULL;
      CC_MANOEUVREFACTORY(obj)->sizeDummyManoeuvre = 1;
     CC_MANOEUVREFACTORY(obj)->poolDummyManoeuvre = (DC_DummyManoeuvre**)malloc( CC_MANOEUVREFACTORY(obj)->sizeDummyManoeuvre*sizeof(DC_DummyManoeuvre*));
    for (unsigned int i=0; i< CC_MANOEUVREFACTORY(obj)->sizeDummyManoeuvre; i++)
        CC_MANOEUVREFACTORY(obj)->poolDummyManoeuvre[i] = pNULL;
      CC_MANOEUVREFACTORY(obj)->sizeTestPUSConfigurableManoeuvre = 1;
     CC_MANOEUVREFACTORY(obj)->poolTestPUSConfigurableManoeuvre = (DC_TestPUSConfigurableManoeuvre**)malloc( CC_MANOEUVREFACTORY(obj)->sizeTestPUSConfigurableManoeuvre*sizeof(DC_TestPUSConfigurableManoeuvre*));
    for (unsigned int i=0; i< CC_MANOEUVREFACTORY(obj)->sizeTestPUSConfigurableManoeuvre; i++)
        CC_MANOEUVREFACTORY(obj)->poolTestPUSConfigurableManoeuvre[i] = pNULL;
      

}

CC_ManoeuvreFactory* CC_ManoeuvreFactory_new(void)
{
        return (CC_ManoeuvreFactory*)object_new(TYPE_CC_MANOEUVREFACTORY);

}



///////////////////////////////////////////////////////////////////////////////
//
//                   binding and type registration
//
///////////////////////////////////////////////////////////////////////////////

static void class_init(ObjectClass *oc, void *data)
{
CC_ManoeuvreFactoryClass *dc_p_class = CC_MANOEUVREFACTORY_CLASS(oc);

        dc_p_class->isObjectConfigured = isObjectConfigured;

}

static const TypeInfo type_info = {
        .name = TYPE_CC_MANOEUVREFACTORY,
        .parent = TYPE_CC_ROOTOBJECT,
        .instance_size = sizeof(CC_ManoeuvreFactory),
        .abstract = false,
        .class_size = sizeof(CC_ManoeuvreFactoryClass),
        .instance_init = instance_init,
        .class_init = class_init,

};

void CC_ManoeuvreFactory_register(void)
{
        type_register_static(&type_info);

}

